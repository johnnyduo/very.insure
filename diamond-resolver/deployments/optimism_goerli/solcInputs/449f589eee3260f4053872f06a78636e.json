{
  "language": "Solidity",
  "sources": {
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@eth-optimism/contracts-bedrock/contracts/universal/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Semver\n * @notice Semver is a simple contract for managing contract versions.\n */\ncontract Semver {\n    /**\n     * @notice Contract version number (major).\n     */\n    uint256 private immutable MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    uint256 private immutable MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    uint256 private immutable PATCH_VERSION;\n\n    /**\n     * @param _major Version number (major).\n     * @param _minor Version number (minor).\n     * @param _patch Version number (patch).\n     */\n    constructor(\n        uint256 _major,\n        uint256 _minor,\n        uint256 _patch\n    ) {\n        MAJOR_VERSION = _major;\n        MINOR_VERSION = _minor;\n        PATCH_VERSION = _patch;\n    }\n\n    /**\n     * @notice Returns the full semver contract version.\n     *\n     * @return Semver contract version as a string.\n     */\n    function version() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Strings.toString(MAJOR_VERSION),\n                    \".\",\n                    Strings.toString(MINOR_VERSION),\n                    \".\",\n                    Strings.toString(PATCH_VERSION)\n                )\n            );\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\n\ninterface IOwnable is IOwnableInternal, IERC173 {}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {\n    error Ownable__NotOwner();\n    error Ownable__NotTransitiveOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnable } from './IOwnable.sol';\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\n\ninterface ISafeOwnable is ISafeOwnableInternal, IOwnable {\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function nomineeOwner() external view returns (address);\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnableInternal } from './IOwnableInternal.sol';\n\ninterface ISafeOwnableInternal is IOwnableInternal {\n    error SafeOwnable__NotNomineeOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { IOwnable } from './IOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IOwnable, OwnableInternal {\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual returns (address) {\n        return _owner();\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account) public virtual onlyOwner {\n        _transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using AddressUtils for address;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\n        _;\n    }\n\n    modifier onlyTransitiveOwner() {\n        if (msg.sender != _transitiveOwner())\n            revert Ownable__NotTransitiveOwner();\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transitiveOwner() internal view virtual returns (address owner) {\n        owner = _owner();\n\n        while (owner.isContract()) {\n            try IERC173(owner).owner() returns (address transitiveOwner) {\n                owner = transitiveOwner;\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        _setOwner(account);\n    }\n\n    function _setOwner(address account) internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, account);\n        l.owner = account;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { Ownable } from './Ownable.sol';\nimport { ISafeOwnable } from './ISafeOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function nomineeOwner() public view virtual returns (address) {\n        return _nomineeOwner();\n    }\n\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        _acceptOwnership();\n    }\n\n    function _transferOwnership(\n        address account\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\n        super._transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\n    modifier onlyNomineeOwner() {\n        if (msg.sender != _nomineeOwner())\n            revert SafeOwnable__NotNomineeOwner();\n        _;\n    }\n\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function _nomineeOwner() internal view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function _acceptOwnership() internal virtual {\n        _setOwner(msg.sender);\n        delete SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @notice set nominee owner, granting permission to call acceptOwnership\n     */\n    function _transferOwnership(address account) internal virtual override {\n        SafeOwnableStorage.layout().nomineeOwner = account;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return contract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view virtual returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(\n        bytes4 interfaceId,\n        bool status\n    ) internal virtual {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { Proxy } from '../../Proxy.sol';\nimport { IDiamondBase } from './IDiamondBase.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy base contract\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\nabstract contract DiamondBase is IDiamondBase, Proxy {\n    /**\n     * @inheritdoc Proxy\n     */\n    function _getImplementation()\n        internal\n        view\n        virtual\n        override\n        returns (address implementation)\n    {\n        // inline storage layout retrieval uses less gas\n        DiamondBaseStorage.Layout storage l;\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n\n        implementation = address(bytes20(l.facets[msg.sig]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/IDiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IProxy } from '../../IProxy.sol';\n\ninterface IDiamondBase is IProxy {}\n"
    },
    "@solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { DiamondBase } from '../base/DiamondBase.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondFallback } from './IDiamondFallback.sol';\n\n// TODO: DiamondFallback interface\n\n/**\n * @title Fallback feature for EIP-2535 \"Diamond\" proxy\n */\nabstract contract DiamondFallback is\n    IDiamondFallback,\n    OwnableInternal,\n    DiamondBase\n{\n    /**\n     * @inheritdoc IDiamondFallback\n     */\n    function getFallbackAddress()\n        external\n        view\n        returns (address fallbackAddress)\n    {\n        fallbackAddress = _getFallbackAddress();\n    }\n\n    /**\n     * @inheritdoc IDiamondFallback\n     */\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\n        _setFallbackAddress(fallbackAddress);\n    }\n\n    /**\n     * @inheritdoc DiamondBase\n     * @notice query custom fallback address is no implementation is found\n     */\n    function _getImplementation()\n        internal\n        view\n        virtual\n        override\n        returns (address implementation)\n    {\n        implementation = super._getImplementation();\n\n        if (implementation == address(0)) {\n            implementation = _getFallbackAddress();\n        }\n    }\n\n    /**\n     * @notice query the address of the fallback implementation\n     * @return fallbackAddress address of fallback implementation\n     */\n    function _getFallbackAddress()\n        internal\n        view\n        virtual\n        returns (address fallbackAddress)\n    {\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\n    }\n\n    /**\n     * @notice set the address of the fallback implementation\n     * @param fallbackAddress address of fallback implementation\n     */\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IDiamondBase } from '../base/IDiamondBase.sol';\n\ninterface IDiamondFallback is IDiamondBase {\n    /**\n     * @notice query the address of the fallback implementation\n     * @return fallbackAddress address of fallback implementation\n     */\n    function getFallbackAddress()\n        external\n        view\n        returns (address fallbackAddress);\n\n    /**\n     * @notice set the address of the fallback implementation\n     * @param fallbackAddress address of fallback implementation\n     */\n    function setFallbackAddress(address fallbackAddress) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISafeOwnable } from '../../access/ownable/ISafeOwnable.sol';\nimport { IERC165 } from '../../interfaces/IERC165.sol';\nimport { IDiamondBase } from './base/IDiamondBase.sol';\nimport { IDiamondFallback } from './fallback/IDiamondFallback.sol';\nimport { IDiamondReadable } from './readable/IDiamondReadable.sol';\nimport { IDiamondWritable } from './writable/IDiamondWritable.sol';\n\ninterface ISolidStateDiamond is\n    IDiamondBase,\n    IDiamondFallback,\n    IDiamondReadable,\n    IDiamondWritable,\n    ISafeOwnable,\n    IERC165\n{\n    receive() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondReadable } from './IDiamondReadable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy introspection contract\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nabstract contract DiamondReadable is IDiamondReadable {\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facets() external view returns (Facet[] memory diamondFacets) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        diamondFacets = new Facet[](l.selectorCount);\n\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (diamondFacets[facetIndex].target == facet) {\n                        diamondFacets[facetIndex].selectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                diamondFacets[numFacets].target = facet;\n                diamondFacets[numFacets].selectors = new bytes4[](\n                    l.selectorCount\n                );\n                diamondFacets[numFacets].selectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\n\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        // setting the number of facets\n        assembly {\n            mstore(diamondFacets, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        selectors = new bytes4[](l.selectorCount);\n\n        uint256 numSelectors;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\n                if (facet == address(bytes20(l.facets[selector]))) {\n                    selectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        // set the number of selectors in the array\n        assembly {\n            mstore(selectors, numSelectors)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        addresses = new address[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facet == addresses[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                addresses[numFacets] = facet;\n                numFacets++;\n            }\n        }\n\n        // set the number of facet addresses in the array\n        assembly {\n            mstore(addresses, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet) {\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondReadable {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { IDiamondWritable } from './IDiamondWritable.sol';\nimport { DiamondWritableInternal } from './DiamondWritableInternal.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy update contract\n */\nabstract contract DiamondWritable is\n    IDiamondWritable,\n    DiamondWritableInternal,\n    OwnableInternal\n{\n    /**\n     * @inheritdoc IDiamondWritable\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external onlyOwner {\n        _diamondCut(facetCuts, target, data);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\n\nabstract contract DiamondWritableInternal is IDiamondWritableInternal {\n    using AddressUtils for address;\n\n    bytes32 private constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 private constant CLEAR_SELECTOR_MASK =\n        bytes32(uint256(0xffffffff << 224));\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function _diamondCut(\n        FacetCut[] memory facetCuts,\n        address target,\n        bytes memory data\n    ) internal {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        unchecked {\n            uint256 originalSelectorCount = l.selectorCount;\n            uint256 selectorCount = originalSelectorCount;\n            bytes32 selectorSlot;\n\n            // Check if last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                // get last selectorSlot\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\n            }\n\n            for (uint256 i; i < facetCuts.length; i++) {\n                FacetCut memory facetCut = facetCuts[i];\n                FacetCutAction action = facetCut.action;\n\n                if (facetCut.selectors.length == 0)\n                    revert DiamondWritable__SelectorNotSpecified();\n\n                if (action == FacetCutAction.ADD) {\n                    (selectorCount, selectorSlot) = _addFacetSelectors(\n                        l,\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                } else if (action == FacetCutAction.REPLACE) {\n                    _replaceFacetSelectors(l, facetCut);\n                } else if (action == FacetCutAction.REMOVE) {\n                    (selectorCount, selectorSlot) = _removeFacetSelectors(\n                        l,\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                }\n            }\n\n            if (selectorCount != originalSelectorCount) {\n                l.selectorCount = uint16(selectorCount);\n            }\n\n            // If last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\n            }\n\n            emit DiamondCut(facetCuts, target, data);\n            _initialize(target, data);\n        }\n    }\n\n    function _addFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            if (\n                facetCut.target != address(this) &&\n                !facetCut.target.isContract()\n            ) revert DiamondWritable__TargetHasNoCode();\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                if (address(bytes20(oldFacet)) != address(0))\n                    revert DiamondWritable__SelectorAlreadyAdded();\n\n                // add facet for selector\n                l.facets[selector] =\n                    bytes20(facetCut.target) |\n                    bytes32(selectorCount);\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\n\n                // clear selector position in slot and add selector\n                selectorSlot =\n                    (selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\n                    selectorSlot = 0;\n                }\n\n                selectorCount++;\n            }\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function _removeFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            if (facetCut.target != address(0))\n                revert DiamondWritable__RemoveTargetNotZeroAddress();\n\n            uint256 selectorSlotCount = selectorCount >> 3;\n            uint256 selectorInSlotIndex = selectorCount & 7;\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                if (address(bytes20(oldFacet)) == address(0))\n                    revert DiamondWritable__SelectorNotFound();\n\n                if (address(bytes20(oldFacet)) == address(this))\n                    revert DiamondWritable__SelectorIsImmutable();\n\n                if (selectorSlot == 0) {\n                    selectorSlotCount--;\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                // adding a block here prevents stack too deep error\n                {\n                    // replace selector with last selector in l.facets\n                    lastSelector = bytes4(\n                        selectorSlot << (selectorInSlotIndex << 5)\n                    );\n\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        l.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(l.facets[lastSelector]);\n                    }\n\n                    delete l.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = l.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    // update storage with the modified slot\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    selectorSlot =\n                        (selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete l.selectorSlots[selectorSlotCount];\n                    selectorSlot = 0;\n                }\n            }\n\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function _replaceFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        FacetCut memory facetCut\n    ) internal {\n        unchecked {\n            if (!facetCut.target.isContract())\n                revert DiamondWritable__TargetHasNoCode();\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                if (oldFacetAddress == address(0))\n                    revert DiamondWritable__SelectorNotFound();\n                if (oldFacetAddress == address(this))\n                    revert DiamondWritable__SelectorIsImmutable();\n                if (oldFacetAddress == facetCut.target)\n                    revert DiamondWritable__ReplaceTargetIsIdentical();\n\n                // replace old facet address\n                l.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(facetCut.target);\n            }\n        }\n    }\n\n    function _initialize(address target, bytes memory data) private {\n        if ((target == address(0)) != (data.length == 0))\n            revert DiamondWritable__InvalidInitializationParameters();\n\n        if (target != address(0)) {\n            if (target != address(this)) {\n                if (!target.isContract())\n                    revert DiamondWritable__TargetHasNoCode();\n            }\n\n            (bool success, ) = target.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\n\n/**\n * @title Diamond proxy upgrade interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondWritable is IDiamondWritableInternal {\n    /**\n     * @notice update diamond facets and optionally execute arbitrary initialization function\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional target of initialization delegatecall\n     * @param data optional initialization function call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IDiamondWritableInternal {\n    enum FacetCutAction {\n        ADD,\n        REPLACE,\n        REMOVE\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\n\n    error DiamondWritable__InvalidInitializationParameters();\n    error DiamondWritable__RemoveTargetNotZeroAddress();\n    error DiamondWritable__ReplaceTargetIsIdentical();\n    error DiamondWritable__SelectorAlreadyAdded();\n    error DiamondWritable__SelectorIsImmutable();\n    error DiamondWritable__SelectorNotFound();\n    error DiamondWritable__SelectorNotSpecified();\n    error DiamondWritable__TargetHasNoCode();\n\n    struct FacetCut {\n        address target;\n        FacetCutAction action;\n        bytes4[] selectors;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IProxy {\n    error Proxy__ImplementationIsNotContract();\n\n    fallback() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\nimport { IProxy } from './IProxy.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy is IProxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        if (!implementation.isContract())\n            revert Proxy__ImplementationIsNotContract();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/attestation/AttestationStation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\nimport { Semver } from \"@eth-optimism/contracts-bedrock/contracts/universal/Semver.sol\";\r\n\r\n/**\r\n * @title AttestationStation\r\n * @author Optimism Collective\r\n * @author Gitcoin\r\n * @notice Where attestations live.\r\n */\r\ncontract AttestationStation is Semver {\r\n    /**\r\n     * @notice Struct representing data that is being attested.\r\n     *\r\n     * @custom:field about Address for which the attestation is about.\r\n     * @custom:field key   A bytes32 key for the attestation.\r\n     * @custom:field val   The attestation as arbitrary bytes.\r\n     */\r\n    struct AttestationData {\r\n        address about;\r\n        bytes32 key;\r\n        bytes val;\r\n    }\r\n\r\n    /**\r\n     * @notice Maps addresses to attestations. Creator => About => Key => Value.\r\n     */\r\n    mapping(address => mapping(address => mapping(bytes32 => bytes))) public attestations;\r\n\r\n    /**\r\n     * @notice Emitted when Attestation is created.\r\n     *\r\n     * @param creator Address that made the attestation.\r\n     * @param about   Address attestation is about.\r\n     * @param key     Key of the attestation.\r\n     * @param val     Value of the attestation.\r\n     */\r\n    event AttestationCreated(\r\n        address indexed creator,\r\n        address indexed about,\r\n        bytes32 indexed key,\r\n        bytes val\r\n    );\r\n\r\n    /**\r\n     * @custom:semver 1.1.0\r\n     */\r\n    constructor() Semver(1, 1, 0) {}\r\n\r\n    /**\r\n     * @notice Allows anyone to create an attestation.\r\n     *\r\n     * @param _about Address that the attestation is about.\r\n     * @param _key   A key used to namespace the attestation.\r\n     * @param _val   An arbitrary value stored as part of the attestation.\r\n     */\r\n    function attest(\r\n        address _about,\r\n        bytes32 _key,\r\n        bytes memory _val\r\n    ) public {\r\n        attestations[msg.sender][_about][_key] = _val;\r\n\r\n        emit AttestationCreated(msg.sender, _about, _key, _val);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows anyone to create attestations.\r\n     *\r\n     * @param _attestations An array of attestation data.\r\n     */\r\n    function attest(AttestationData[] calldata _attestations) external {\r\n        uint256 length = _attestations.length;\r\n        for (uint256 i = 0; i < length; ) {\r\n            AttestationData memory attestation = _attestations[i];\r\n\r\n            attest(attestation.about, attestation.key, attestation.val);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}"
    },
    "contracts/attestation/OptiDomainsAttestation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\nimport {INameWrapperRegistry} from \"../diamond-resolver/INameWrapperRegistry.sol\";\r\nimport \"./AttestationStation.sol\";\r\n\r\nbytes32 constant VERSION_KEY = keccak256(\"optidomains.resolver.VersionStorage\");\r\n\r\nerror NotResolver(address caller, address resolver);\r\n\r\ncontract OptiDomainsAttestation {\r\n    INameWrapperRegistry public immutable registry;\r\n    AttestationStation public immutable attestationStation;\r\n    bool public attestationActivated;\r\n\r\n    // In case attestation is not created -> simulate it in this contract\r\n\r\n    /**\r\n     * @notice Maps addresses to attestations. Creator => About => Key => Value.\r\n     */\r\n    mapping(address => mapping(address => mapping(bytes32 => bytes)))\r\n        public attestations;\r\n\r\n    /**\r\n     * @notice Emitted when Attestation is created.\r\n     *\r\n     * @param creator Address that made the attestation.\r\n     * @param about   Address attestation is about.\r\n     * @param key     Key of the attestation.\r\n     * @param val     Value of the attestation.\r\n     */\r\n    event AttestationCreated(\r\n        address indexed creator,\r\n        address indexed about,\r\n        bytes32 indexed key,\r\n        bytes val\r\n    );\r\n\r\n    function _attestLocal(address _about, bytes32 _key, bytes memory _val) internal {\r\n        attestations[address(this)][_about][_key] = _val;\r\n        emit AttestationCreated(address(this), _about, _key, _val);\r\n    }\r\n\r\n    function isContract(address _addr) private view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    constructor(\r\n        INameWrapperRegistry _registry,\r\n        AttestationStation _attestationStation\r\n    ) {\r\n        registry = _registry;\r\n        attestationStation = _attestationStation;\r\n        attestationActivated = isContract(address(_attestationStation));\r\n    }\r\n\r\n    function activate() public {\r\n        attestationActivated = isContract(address(attestationStation));\r\n    }\r\n\r\n    function _attest(AttestationStation.AttestationData[] memory _attestations) internal {\r\n        if (attestationActivated) {\r\n            attestationStation.attest(_attestations);\r\n        } else {\r\n            uint256 length = _attestations.length;\r\n            for (uint256 i = 0; i < length; ) {\r\n                AttestationStation.AttestationData memory attestation = _attestations[i];\r\n\r\n                _attestLocal(attestation.about, attestation.key, attestation.val);\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _readVersion(address owner, bytes32 node) internal view returns(uint64) {\r\n        return abi.decode(attestationStation.attestations(address(this), owner, keccak256(abi.encodePacked(node, VERSION_KEY))), (uint64));\r\n    }\r\n\r\n    function readVersion(bytes32 node) public view returns(uint64) {\r\n        return _readVersion(registry.ownerOf(node), node);\r\n    }\r\n\r\n    function readAttestation(address creator, bytes32 node, bytes32 key) public view returns(bytes memory) {\r\n        address owner = registry.ownerOf(node);\r\n        uint64 version = _readVersion(owner, node);\r\n        return attestationStation.attestations(creator, owner, keccak256(abi.encodePacked(node, key, version)));\r\n    }\r\n\r\n    function readAttestation(bytes32 node, bytes32 key) public view returns(bytes memory) {\r\n        return readAttestation(address(this), node, key);\r\n    }\r\n\r\n    // Attest by resolver\r\n    function attest(bytes32 node, bytes32 key, bytes memory value) public {\r\n        address resolver = registry.ens().resolver(node);\r\n        if (msg.sender != resolver) {\r\n            revert NotResolver(msg.sender, resolver);\r\n        }\r\n\r\n        address owner = registry.ownerOf(node);\r\n        uint64 version = _readVersion(owner, node);\r\n\r\n        AttestationStation.AttestationData[] memory att = new AttestationStation.AttestationData[](2);\r\n        \r\n        att[0] = AttestationStation.AttestationData({\r\n            about: owner,\r\n            key: keccak256(abi.encodePacked(node, key)),\r\n            val: value\r\n        });\r\n\r\n        att[1] = AttestationStation.AttestationData({\r\n            about: owner,\r\n            key: keccak256(abi.encodePacked(node, key, version)),\r\n            val: value\r\n        });\r\n\r\n        _attest(att);\r\n    }\r\n\r\n    // Increase version by resolver\r\n    function increaseVersion(bytes32 node) public {\r\n        address resolver = registry.ens().resolver(node);\r\n        if (msg.sender != resolver) {\r\n            revert NotResolver(msg.sender, resolver);\r\n        }\r\n\r\n        address owner = registry.ownerOf(node);\r\n        uint64 version = _readVersion(owner, node);\r\n\r\n        AttestationStation.AttestationData[] memory att = new AttestationStation.AttestationData[](1);\r\n        \r\n        att[0] = AttestationStation.AttestationData({\r\n            about: owner,\r\n            key: keccak256(abi.encodePacked(node, VERSION_KEY)),\r\n            val: abi.encode(version + 1)\r\n        });\r\n\r\n        _attest(att);\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/DiamondBaseExtendable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport { OwnableInternal } from '@solidstate/contracts/access/ownable/OwnableInternal.sol';\r\nimport { DiamondBaseStorage } from '@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol';\r\nimport { IDiamondFallback } from '@solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol';\r\nimport { Proxy } from '@solidstate/contracts/proxy/Proxy.sol';\r\n\r\ninterface IDiamondBaseExtendable is IDiamondFallback {\r\n    function getImplementation(bytes4 sig) external view returns (address);\r\n}\r\n\r\n/**\r\n * @title Fallback feature for EIP-2535 \"Diamond\" proxy\r\n */\r\nabstract contract DiamondBaseExtendable is\r\n    IDiamondBaseExtendable,\r\n    Proxy,\r\n    OwnableInternal\r\n{\r\n    /**\r\n     * @inheritdoc IDiamondFallback\r\n     */\r\n    function getFallbackAddress()\r\n        external\r\n        view\r\n        returns (address fallbackAddress)\r\n    {\r\n        fallbackAddress = _getFallbackAddress();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondFallback\r\n     */\r\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\r\n        _setFallbackAddress(fallbackAddress);\r\n    }\r\n\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (address implementation)\r\n    {\r\n        implementation = getImplementation(msg.sig);\r\n    }\r\n\r\n    function getImplementation(bytes4 sig) public view virtual returns (address implementation) {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondBaseStorage.Layout storage l;\r\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        implementation = address(bytes20(l.facets[sig]));\r\n\r\n        if (implementation == address(0)) {\r\n            implementation = _getFallbackAddress();\r\n            if (implementation != address(0)) {\r\n                implementation = IDiamondBaseExtendable(payable(implementation)).getImplementation(sig);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice query the address of the fallback implementation\r\n     * @return fallbackAddress address of fallback implementation\r\n     */\r\n    function _getFallbackAddress()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address fallbackAddress)\r\n    {\r\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice set the address of the fallback implementation\r\n     * @param fallbackAddress address of fallback implementation\r\n     */\r\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\r\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/DiamondResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport \"./SolidStateDiamond.sol\";\r\nimport \"./Multicallable.sol\";\r\nimport \"./IDiamondResolver.sol\";\r\nimport \"./facets/base/IDiamondResolverBase.sol\";\r\nimport \"./facets/base/DiamondResolverBase.sol\";\r\nimport \"../registry/ENS.sol\";\r\nimport \"./INameWrapperRegistry.sol\";\r\nimport {IReverseRegistrar} from \"../reverseRegistrar/IReverseRegistrar.sol\";\r\nimport {ReverseClaimer} from \"../reverseRegistrar/ReverseClaimer.sol\";\r\nimport {INameWrapper} from \"../wrapper/INameWrapper.sol\";\r\n\r\nbytes4 constant supportsInterfaceSignature = 0x01ffc9a7;\r\n\r\ncontract DiamondResolver is \r\n    SolidStateDiamond,\r\n    Multicallable,\r\n    DiamondResolverBase\r\n{\r\n    bytes32 constant ADDR_REVERSE_NODE =\r\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    INameWrapperRegistry public immutable registry;\r\n\r\n    constructor(address _owner, INameWrapperRegistry _registry) SolidStateDiamond(_owner) {\r\n        registry = _registry;\r\n    }\r\n\r\n    function initialize(address _owner, address _fallback) public virtual override {\r\n        super.initialize(_owner, _fallback);\r\n\r\n        if (_fallback == address(0)) {\r\n            bytes4[] memory selectors = new bytes4[](8);\r\n            uint256 selectorIndex;\r\n\r\n            // register DiamondResolverBase\r\n\r\n            selectors[selectorIndex++] = IHasNameWrapperRegistry.registry.selector;\r\n            selectors[selectorIndex++] = IDiamondResolverBase.setApprovalForAll.selector;\r\n            selectors[selectorIndex++] = IDiamondResolverBase.isApprovedForAll.selector;\r\n            selectors[selectorIndex++] = IDiamondResolverBase.approve.selector;\r\n            selectors[selectorIndex++] = IDiamondResolverBase.isApprovedFor.selector;\r\n            selectors[selectorIndex++] = IVersionableResolver.recordVersions.selector;\r\n            selectors[selectorIndex++] = IVersionableResolver.clearRecords.selector;\r\n            selectors[selectorIndex++] = IDiamondResolverFactory.clone.selector;\r\n\r\n            // diamond cut\r\n\r\n            FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n            facetCuts[0] = FacetCut({\r\n                target: address(this),\r\n                action: FacetCutAction.ADD,\r\n                selectors: selectors\r\n            });\r\n\r\n            _diamondCut(facetCuts, address(0), '');\r\n        }\r\n\r\n        _setSupportsInterface(type(IDiamondResolver).interfaceId, true);\r\n        _setSupportsInterface(type(IVersionableResolver).interfaceId, true);\r\n        _setSupportsInterface(type(IHasNameWrapperRegistry).interfaceId, true);\r\n        _setSupportsInterface(type(IDiamondResolverFactory).interfaceId, true);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(Multicallable, SolidStateDiamond)\r\n        returns (bool)\r\n    {\r\n        return SolidStateDiamond.supportsInterface(interfaceID) || Multicallable.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/DiamondResolverOverrider.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport \"./facets/base/DiamondResolverUtil.sol\";\r\n\r\nerror Overrider_SignatureBlacklisted(bytes4 sig);\r\nerror Overrider_ImplementationNotWhitelisted(address implementation);\r\n\r\nlibrary DiamondResolverOverriderStorage {\r\n    struct Layout {\r\n        // Facets overriding mapping\r\n        mapping(bytes32 => mapping(bytes4 => address)) facets;\r\n\r\n        // Blacklisted function signature\r\n        mapping(bytes4 => bool) blacklisted;\r\n\r\n        // Whitelisted implementation address\r\n        mapping(address => bool) whitelisted;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\r\n            \"optidomains.contracts.storage.DiamondResolverOverriderStorage\"\r\n        );\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\ncontract DiamondResolverOverrider is DiamondResolverUtil {\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        if (msg.data.length < 36) {\r\n            return address(0);\r\n        }\r\n\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondResolverOverriderStorage.Layout storage l;\r\n        bytes32 slot = DiamondResolverOverriderStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        if (l.blacklisted[msg.sig]) {\r\n            return address(0);\r\n        }\r\n\r\n        return l.facets[bytes32(msg.data[4:36])][msg.sig];\r\n    }\r\n\r\n    function setOverrideBlacklist(bytes4[] memory sig, bool blacklisted) public baseOnlyOwner {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondResolverOverriderStorage.Layout storage l;\r\n        bytes32 slot = DiamondResolverOverriderStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        unchecked {\r\n            uint256 sigLength = sig.length;\r\n            for (uint256 i; i < sigLength; ++i) {\r\n                l.blacklisted[sig[i]] = blacklisted;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setWhitelistedImplementation(address[] memory implementations, bool whitelisted) public baseOnlyOwner {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondResolverOverriderStorage.Layout storage l;\r\n        bytes32 slot = DiamondResolverOverriderStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        unchecked {\r\n            uint256 implLength = implementations.length;\r\n            for (uint256 i; i < implLength; ++i) {\r\n                l.whitelisted[implementations[i]] = whitelisted;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setOverride(bytes32 node, bytes4 sig, address implementation) public authorised(node) {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondResolverOverriderStorage.Layout storage l;\r\n        bytes32 slot = DiamondResolverOverriderStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        if (l.blacklisted[sig]) {\r\n            revert Overrider_SignatureBlacklisted(sig);\r\n        }\r\n\r\n        if (!l.whitelisted[implementation]) {\r\n            revert Overrider_ImplementationNotWhitelisted(implementation);\r\n        }\r\n\r\n        l.facets[node][sig] = implementation;\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/auth/OwnedAuthFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../base/DiamondResolverBaseInternal.sol\";\r\nimport \"../base/IDiamondResolverAuth.sol\";\r\n\r\ncontract OwnedAuthFacet is DiamondResolverBaseInternal, IDiamondResolverAuth {\r\n    function isAuthorised(address sender, bytes32) public virtual view returns (bool) {\r\n        return sender == OwnableStorage.layout().owner;\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/auth/RegistryAuthFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../base/DiamondResolverBaseInternal.sol\";\r\nimport \"../base/IDiamondResolverAuth.sol\";\r\nimport \"../../IDiamondResolver.sol\";\r\n\r\ncontract RegistryAuthFacet is DiamondResolverBaseInternal, IDiamondResolverAuth {\r\n    function isAuthorised(address sender, bytes32 node) public virtual view returns (bool) {\r\n        address owner = IHasNameWrapperRegistry(address(this)).registry().ownerOf(node);\r\n\r\n        return\r\n            owner == sender ||\r\n            _isApprovedForAll(owner, sender) ||\r\n            _isApprovedFor(owner, node, sender);\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/auth/RegistryWhitelistAuthFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./RegistryAuthFacet.sol\";\r\n\r\nlibrary RegistryWhitelistAuthStorage {\r\n    struct Layout {\r\n        /**\r\n         * trustedETHController and trustedReverseRegistrar has right to control any name regardless of approval\r\n         * controller address => whitelisted\r\n         */\r\n        mapping(address => bool) whitelisted;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('optidomains.contracts.storage.RegistryWhitelistAuthStorage');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\ncontract RegistryWhitelistAuthFacet is RegistryAuthFacet {\r\n    event SetWhitelisted(address indexed operator, bool approved);\r\n\r\n    function isAuthorised(address sender, bytes32 node) public virtual override view returns (bool) {\r\n        return super.isAuthorised(sender, node) || RegistryWhitelistAuthStorage.layout().whitelisted[sender];\r\n    }\r\n\r\n    function setWhitelisted(address operator, bool approved) public baseOnlyOwner {\r\n        RegistryWhitelistAuthStorage.Layout storage l = RegistryWhitelistAuthStorage\r\n            .layout();\r\n        l.whitelisted[operator] = approved;\r\n        emit SetWhitelisted(operator, approved);\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/DiamondResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport {ERC165BaseInternal} from \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\";\r\nimport \"./DiamondResolverBaseInternal.sol\";\r\nimport \"./DiamondResolverFactory.sol\";\r\nimport \"./IDiamondResolverBase.sol\";\r\n\r\nabstract contract DiamondResolverBase is\r\n    IDiamondResolverBase,\r\n    DiamondResolverBaseInternal,\r\n    DiamondResolverFactory,\r\n    ERC165BaseInternal\r\n{\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public {\r\n        _setApprovalForAll(operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(\r\n        address account,\r\n        address operator\r\n    ) public view returns (bool) {\r\n        return _isApprovedForAll(account, operator);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve a delegate to be able to updated records on a node.\r\n     */\r\n    function approve(bytes32 node, address delegate, bool approved) public {\r\n        _approve(node, delegate, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Check to see if the delegate has been approved by the owner for the node.\r\n     */\r\n    function isApprovedFor(\r\n        address owner,\r\n        bytes32 node,\r\n        address delegate\r\n    ) public view returns (bool) {\r\n        return _isApprovedFor(owner, node, delegate);\r\n    }\r\n\r\n    function recordVersions(bytes32 node) public view returns (uint64) {\r\n        return _recordVersions(node);\r\n    }\r\n\r\n    /**\r\n     * Increments the record version associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     */\r\n    function clearRecords(bytes32 node) public virtual authorised(node) {\r\n        _clearRecords(node);\r\n    }\r\n\r\n    function setSupportsInterface(bytes4 interfaceId, bool status) public baseOnlyOwner {\r\n        _setSupportsInterface(interfaceId, status);\r\n    }\r\n\r\n    function setMultiSupportsInterface(bytes4[] memory interfaceId, bool status) public baseOnlyOwner {\r\n        unchecked {\r\n            uint length = interfaceId.length;\r\n            for (uint i; i < length; ++i) {\r\n                _setSupportsInterface(interfaceId[i], status);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/DiamondResolverBaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./DiamondResolverBaseStorage.sol\";\r\nimport \"./DiamondResolverUtil.sol\";\r\n\r\nerror ERC165Base__InvalidInterfaceId();\r\n\r\nabstract contract DiamondResolverBaseInternal is DiamondResolverUtil {\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    // Logged when a delegate is approved or an approval is revoked.\r\n    event Approved(\r\n        address owner,\r\n        bytes32 indexed node,\r\n        address indexed delegate,\r\n        bool indexed approved\r\n    );\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function _setApprovalForAll(address operator, bool approved) internal {\r\n        require(\r\n            msg.sender != operator,\r\n            \"ERC1155: setting approval status for self\"\r\n        );\r\n\r\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\r\n            .layout();\r\n        l.operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve a delegate to be able to updated records on a node.\r\n     */\r\n    function _approve(bytes32 node, address delegate, bool approved) internal {\r\n        require(msg.sender != delegate, \"Setting delegate status for self\");\r\n\r\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\r\n            .layout();\r\n        l.tokenApprovals[msg.sender][node][delegate] = approved;\r\n        emit Approved(msg.sender, node, delegate, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function _isApprovedForAll(\r\n        address account,\r\n        address operator\r\n    ) internal view returns (bool) {\r\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\r\n            .layout();\r\n        return l.operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Check to see if the delegate has been approved by the owner for the node.\r\n     */\r\n    function _isApprovedFor(\r\n        address owner,\r\n        bytes32 node,\r\n        address delegate\r\n    ) internal view returns (bool) {\r\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\r\n            .layout();\r\n        return l.tokenApprovals[owner][node][delegate];\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/DiamondResolverBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"../../../registry/ENS.sol\";\r\nimport {INameWrapper} from \"../../../wrapper/INameWrapper.sol\";\r\n\r\n/**\r\n * @dev derived from PublicResolver (MIT license)\r\n */\r\nlibrary DiamondResolverBaseStorage {\r\n    struct Layout {\r\n        /**\r\n         * A mapping of operators. An address that is authorised for an address\r\n         * may make any changes to the name that the owner could, but may not update\r\n         * the set of authorisations.\r\n         * (owner, operator) => approved\r\n         */\r\n        mapping(address => mapping(address => bool)) operatorApprovals;\r\n\r\n        /**\r\n         * A mapping of delegates. A delegate that is authorised by an owner\r\n         * for a name may make changes to the name's resolver, but may not update\r\n         * the set of token approvals.\r\n         * (owner, name, delegate) => approved\r\n         */\r\n        mapping(address => mapping(bytes32 => mapping(address => bool))) tokenApprovals;\r\n\r\n        mapping(bytes32 => uint64) recordVersions;\r\n\r\n        mapping(address => bool) supportsInterface;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('optidomains.contracts.storage.DiamondResolverStorage');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/DiamondResolverFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"./IDiamondResolverFactory.sol\";\r\n\r\ninterface IDiamondResolverInitialize {\r\n    function initialize(address _owner, address _fallback) external;\r\n}\r\n\r\ncontract DiamondResolverFactory is IDiamondResolverFactory {\r\n    event CloneDiamondResolver(address indexed cloner, address indexed resolver);\r\n\r\n    /**\r\n     * Clone DiamondResolver to customize your own resolver\r\n     */\r\n    function clone() public {\r\n        address newResolver = Clones.clone(address(this));\r\n        IDiamondResolverInitialize(newResolver).initialize(msg.sender, address(this));\r\n        emit CloneDiamondResolver(msg.sender, newResolver);\r\n    }\r\n}"
    },
    "contracts/diamond-resolver/facets/base/DiamondResolverUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport {OwnableStorage} from \"@solidstate/contracts/access/ownable/OwnableStorage.sol\";\r\nimport \"./DiamondResolverBaseStorage.sol\";\r\nimport \"./IVersionableResolver.sol\";\r\nimport \"../../INameWrapperRegistry.sol\";\r\nimport \"../../../attestation/OptiDomainsAttestation.sol\";\r\n\r\nerror NotDiamondOwner();\r\n\r\nabstract contract DiamondResolverUtil {\r\n    error Unauthorised();\r\n\r\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\r\n\r\n    modifier baseOnlyOwner() {\r\n        if (msg.sender != OwnableStorage.layout().owner) revert NotDiamondOwner();\r\n        _;\r\n    }\r\n\r\n    function _registry() internal view returns(INameWrapperRegistry) {\r\n        return IHasNameWrapperRegistry(address(this)).registry();\r\n    }\r\n\r\n    function _attestation() internal view returns(OptiDomainsAttestation) {\r\n        return OptiDomainsAttestation(_registry().attestation());\r\n    }\r\n\r\n    function _readAttestation(bytes32 node, bytes32 key) internal view returns(bytes memory) {\r\n        return _attestation().readAttestation(node, key);\r\n    }\r\n\r\n    function _attest(bytes32 node, bytes32 key, bytes memory value) internal {\r\n        _attestation().attest(node, key, value);\r\n    }\r\n\r\n    function _recordVersions(bytes32 node) internal view returns (uint64) {\r\n        return _attestation().readVersion(node);\r\n    }\r\n\r\n    /**\r\n     * Increments the record version associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     */\r\n    function _clearRecords(bytes32 node) internal virtual {\r\n        _attestation().increaseVersion(node);\r\n        emit VersionChanged(node, _recordVersions(node));\r\n    }\r\n\r\n    function _isAuthorised(bytes32 node) internal view returns (bool) {\r\n        (bool success, bytes memory result) = address(this).staticcall(\r\n            abi.encodeWithSelector(0x25f36704, msg.sender, node)\r\n        );\r\n        if (!success) return false;\r\n        return abi.decode(result, (bool));\r\n    }\r\n\r\n    modifier authorised(bytes32 node) {\r\n        if (!_isAuthorised(node)) revert Unauthorised();\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/IDiamondResolverAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IDiamondResolverAuth {\r\n    function isAuthorised(address sender, bytes32 node) external view returns (bool);\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/IDiamondResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./IVersionableResolver.sol\";\r\nimport {INameWrapper} from \"../../../wrapper/INameWrapper.sol\";\r\n\r\ninterface IDiamondResolverBase is IVersionableResolver {\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(\r\n        address account,\r\n        address operator\r\n    ) external view returns (bool);\r\n\r\n    function approve(bytes32 node, address delegate, bool approved) external;\r\n\r\n    function isApprovedFor(\r\n        address owner,\r\n        bytes32 node,\r\n        address delegate\r\n    ) external view returns (bool);\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/base/IDiamondResolverFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IDiamondResolverFactory {\r\n  function clone() external;\r\n}"
    },
    "contracts/diamond-resolver/facets/base/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IVersionableResolver {\n    // event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n    function clearRecords(bytes32 node) external;\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/abi-resolver/ABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"./IABIResolver.sol\";\n\nbytes32 constant ABI_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.ABIResolverStorage\");\n\nlibrary ABIResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('optidomains.contracts.storage.ABIResolverStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract ABIResolver is IABIResolver, DiamondResolverUtil, IERC165 {\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) & contentType) == 0);\n\n        _attest(node, keccak256(abi.encodePacked(ABI_RESOLVER_STORAGE, contentType)), data);\n\n        emit ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view virtual override returns (uint256, bytes memory) {\n        for (\n            uint256 contentType = 1;\n            contentType <= contentTypes;\n            contentType <<= 1\n        ) {\n            bytes memory data = _readAttestation(node, keccak256(abi.encodePacked(ABI_RESOLVER_STORAGE, contentType)));\n            if (\n                (contentType & contentTypes) != 0 &&\n                data.length > 0\n            ) {\n                return (contentType, data);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IABIResolver).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/abi-resolver/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/addr-resolver/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"./IAddrResolver.sol\";\nimport \"./IAddressResolver.sol\";\n\nbytes32 constant ADDR_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.AddrResolverStorage\");\n\nlibrary AddrResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('optidomains.contracts.storage.AddrResolverStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract AddrResolver is\n    IAddrResolver,\n    IAddressResolver,\n    DiamondResolverUtil,\n    IERC165\n{\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(\n        bytes32 node,\n        address a\n    ) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(\n        bytes32 node\n    ) public view virtual override returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public virtual authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n\n        _attest(node, keccak256(abi.encodePacked(ADDR_RESOLVER_STORAGE, coinType)), a);\n    }\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) public view virtual override returns (bytes memory) {\n        return _readAttestation(node, keccak256(abi.encodePacked(ADDR_RESOLVER_STORAGE, coinType)));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId;\n    }\n\n    function bytesToAddress(\n        bytes memory b\n    ) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/addr-resolver/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/addr-resolver/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/content-hash-resolver/ContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"./IContentHashResolver.sol\";\n\nbytes32 constant CONTENT_HASH_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.ContentHashResolverStorage\");\n\nlibrary ContentHashResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('optidomains.contracts.storage.ContentHashResolverStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract ContentHashResolver is IContentHashResolver, DiamondResolverUtil, IERC165 {\n    /**\n     * Sets the contenthash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(\n        bytes32 node,\n        bytes calldata hash\n    ) external virtual authorised(node) {\n        _attest(node, keccak256(abi.encodePacked(CONTENT_HASH_RESOLVER_STORAGE)), hash);\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(\n        bytes32 node\n    ) external view virtual override returns (bytes memory) {\n        return _readAttestation(node, keccak256(abi.encodePacked(CONTENT_HASH_RESOLVER_STORAGE)));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(IContentHashResolver).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/content-hash-resolver/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/dns-resolver/DNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport {IERC165} from \"@solidstate/contracts/interfaces/IERC165.sol\";\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"../../../../dnssec-oracle/RRUtils.sol\";\nimport \"./IDNSRecordResolver.sol\";\nimport \"./IDNSZoneResolver.sol\";\n\nbytes32 constant DNS_RESOLVER_STORAGE_ZONEHASHES = keccak256(\"optidomains.resolver.DNSResolverStorage.zonehashes\");\nbytes32 constant DNS_RESOLVER_STORAGE_RECORDS = keccak256(\"optidomains.resolver.DNSResolverStorage.records\");\nbytes32 constant DNS_RESOLVER_STORAGE_COUNT = keccak256(\"optidomains.resolver.DNSResolverStorage.nameEntriesCount\");\n\nlibrary DNSResolverStorage {\n    struct Layout {\n        // Zone hashes for the domains.\n        // A zone hash is an EIP-1577 content hash in binary format that should point to a\n        // resource containing a single zonefile.\n        // node => contenthash\n        mapping(uint64 => mapping(bytes32 => bytes)) versionable_zonehashes;\n        // The records themselves.  Stored as binary RRSETs\n        // node => version => name => resource => data\n        mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes)))) versionable_records;\n        // Count of number of entries for a given name.  Required for DNS resolvers\n        // when resolving wildcards.\n        // node => version => name => number of records\n        mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16))) versionable_nameEntriesCount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"optidomains.contracts.storage.DNSResolverStorage\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract DNSResolver is\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    DiamondResolverUtil,\n    IERC165\n{\n    using RRUtils for *;\n    using BytesUtils for bytes;\n\n    /**\n     * Set one or more DNS records.  Records are supplied in wire-format.\n     * Records with the same node/name/resource must be supplied one after the\n     * other to ensure the data is updated correctly. For example, if the data\n     * was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     a.example.com IN A 5.6.7.8\n     *     www.example.com IN CNAME a.example.com.\n     * then this would store the two A records for a.example.com correctly as a\n     * single RRSET, however if the data was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     www.example.com IN CNAME a.example.com.\n     *     a.example.com IN A 5.6.7.8\n     * then this would store the first A record, the CNAME, then the second A\n     * record which would overwrite the first.\n     *\n     * @param node the namehash of the node for which to set the records\n     * @param data the DNS wire format records to set\n     */\n    function setDNSRecords(\n        bytes32 node,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        uint16 resource = 0;\n        uint256 offset = 0;\n        bytes memory name;\n        bytes memory value;\n        bytes32 nameHash;\n        // Iterate over the data to add the resource records\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (resource == 0) {\n                resource = iter.dnstype;\n                name = iter.name();\n                nameHash = keccak256(abi.encodePacked(name));\n                value = bytes(iter.rdata());\n            } else {\n                bytes memory newName = iter.name();\n                if (resource != iter.dnstype || !name.equals(newName)) {\n                    setDNSRRSet(\n                        node,\n                        name,\n                        resource,\n                        data,\n                        offset,\n                        iter.offset - offset,\n                        value.length == 0\n                    );\n                    resource = iter.dnstype;\n                    offset = iter.offset;\n                    name = newName;\n                    nameHash = keccak256(name);\n                    value = bytes(iter.rdata());\n                }\n            }\n        }\n        if (name.length > 0) {\n            setDNSRRSet(\n                node,\n                name,\n                resource,\n                data,\n                offset,\n                data.length - offset,\n                value.length == 0\n            );\n        }\n    }\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) public view virtual override returns (bytes memory) {\n        return _readAttestation(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_RECORDS, name, resource)));\n    }\n\n    /**\n     * Check if a given node has records.\n     * @param node the namehash of the node for which to check the records\n     * @param name the namehash of the node for which to check the records\n     */\n    function hasDNSRecords(\n        bytes32 node,\n        bytes32 name\n    ) public view virtual returns (bool) {\n        uint16 count = abi.decode(_readAttestation(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_COUNT, name))), (uint16));\n        return (count != 0);\n    }\n\n    /**\n     * setZonehash sets the hash for the zone.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The zonehash to set\n     */\n    function setZonehash(\n        bytes32 node,\n        bytes calldata hash\n    ) external virtual authorised(node) {\n        bytes memory oldhash = _readAttestation(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_ZONEHASHES)));\n        _attest(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_ZONEHASHES)), hash);\n        emit DNSZonehashChanged(node, oldhash, hash);\n    }\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(\n        bytes32 node\n    ) external view virtual override returns (bytes memory) {\n        return _readAttestation(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_ZONEHASHES)));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\n            interfaceID == type(IDNSZoneResolver).interfaceId;\n    }\n\n    function setDNSRRSet(\n        bytes32 node,\n        bytes memory name,\n        uint16 resource,\n        bytes memory data,\n        uint256 offset,\n        uint256 size,\n        bool deleteRecord\n    ) private {\n        bytes32 nameHash = keccak256(name);\n        bytes memory rrData = data.substring(offset, size);\n        bytes memory oldRecords = dnsRecord(node, nameHash, resource);\n        uint16 nameEntriesCount = abi.decode(_readAttestation(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_COUNT, nameHash))), (uint16));\n        if (deleteRecord) {\n            if (\n                oldRecords.length != 0\n            ) {\n                _attest(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_COUNT, nameHash)), abi.encode(nameEntriesCount - 1));\n            }\n            _attest(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_RECORDS, name, resource)), \"\");\n            emit DNSRecordDeleted(node, name, resource);\n        } else {\n            if (\n                oldRecords.length == 0\n            ) {\n                _attest(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_COUNT, nameHash)), abi.encode(nameEntriesCount + 1));\n            }\n            _attest(node, keccak256(abi.encodePacked(DNS_RESOLVER_STORAGE_RECORDS, name, resource)), rrData);\n            emit DNSRecordChanged(node, name, resource, rrData);\n        }\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/dns-resolver/IDNSRecordResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSRecordResolver {\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/dns-resolver/IDNSZoneResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSZoneResolver {\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/extended-resolver/ExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"./IExtendedResolver.sol\";\n\ncontract ExtendedResolver is IERC165 {\n    function resolve(\n        bytes memory /* name */,\n        bytes memory data\n    ) external view returns (bytes memory) {\n        (bool success, bytes memory result) = address(this).staticcall(data);\n        if (success) {\n            return result;\n        } else {\n            // Revert with the reason provided by the call\n            assembly {\n                revert(add(result, 0x20), mload(result))\n            }\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    )\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return interfaceID == type(IExtendedResolver).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/extended-resolver/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/interface-resolver/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/interface-resolver/InterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../addr-resolver/AddrResolver.sol\";\nimport \"./IInterfaceResolver.sol\";\n\nbytes32 constant INTERFACE_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.InterfaceResolverStorage\");\n\nlibrary InterfaceResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"optidomains.contracts.storage.InterfaceResolverStorage\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\n    /**\n     * Sets an interface associated with a name.\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n     * @param node The node to update.\n     * @param interfaceID The EIP 165 interface ID.\n     * @param implementer The address of a contract that implements this interface for this node.\n     */\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external virtual authorised(node) {\n        _attest(node, keccak256(abi.encodePacked(INTERFACE_RESOLVER_STORAGE, interfaceID)), abi.encode(implementer));\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view virtual override returns (address) {\n        address implementer = abi.decode(_readAttestation(node, keccak256(abi.encodePacked(INTERFACE_RESOLVER_STORAGE, interfaceID))), (address));\n        if (implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if (a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(\n            abi.encodeWithSignature(\n                \"supportsInterface(bytes4)\",\n                type(IERC165).interfaceId\n            )\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // EIP 165 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(\n            abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID)\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IInterfaceResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/name-resolver/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/name-resolver/NameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"./INameResolver.sol\";\n\nbytes32 constant NAME_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.NameResolverStorage\");\n\nlibrary NameResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => string)) versionable_names;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"optidomains.contracts.storage.NameResolverStorage\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract NameResolver is INameResolver, DiamondResolverUtil, IERC165 {\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function setName(\n        bytes32 node,\n        string calldata newName\n    ) external virtual authorised(node) {\n        _attest(node, keccak256(abi.encodePacked(NAME_RESOLVER_STORAGE)), abi.encode(newName));\n        emit NameChanged(node, newName);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(\n        bytes32 node\n    ) external view virtual override returns (string memory) {\n        return abi.decode(_readAttestation(node, keccak256(abi.encodePacked(NAME_RESOLVER_STORAGE))), (string));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(INameResolver).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/pubkey-resolver/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/pubkey-resolver/PubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"./IPubkeyResolver.sol\";\n\nbytes32 constant PUBKEY_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.PubkeyResolverStorage\");\n\nlibrary PubkeyResolverStorage {\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"optidomains.contracts.storage.PubkeyResolverStorage\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract PubkeyResolver is IPubkeyResolver, DiamondResolverUtil, IERC165 {\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    /**\n     * Sets the SECP256k1 public key associated with an ENS node.\n     * @param node The ENS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(\n        bytes32 node,\n        bytes32 x,\n        bytes32 y\n    ) external virtual authorised(node) {\n        _attest(node, keccak256(abi.encodePacked(PUBKEY_RESOLVER_STORAGE)), abi.encode(PublicKey(x, y)));\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(\n        bytes32 node\n    ) external view virtual override returns (bytes32 x, bytes32 y) {\n        PublicKey memory key = abi.decode(_readAttestation(node, keccak256(abi.encodePacked(PUBKEY_RESOLVER_STORAGE))), (PublicKey));\n        return (\n            key.x,\n            key.y\n        );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(IPubkeyResolver).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/PublicResolverFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"./abi-resolver/ABIResolver.sol\";\r\nimport \"./addr-resolver/AddrResolver.sol\";\r\nimport \"./content-hash-resolver/ContentHashResolver.sol\";\r\nimport \"./dns-resolver/DNSResolver.sol\";\r\nimport \"./interface-resolver/InterfaceResolver.sol\";\r\nimport \"./name-resolver/NameResolver.sol\";\r\nimport \"./pubkey-resolver/PubkeyResolver.sol\";\r\nimport \"./text-resolver/TextResolver.sol\";\r\nimport \"./extended-resolver/ExtendedResolver.sol\";\r\n\r\ncontract PublicResolverFacet is\r\n    ABIResolver,\r\n    AddrResolver,\r\n    ContentHashResolver,\r\n    DNSResolver,\r\n    InterfaceResolver,\r\n    NameResolver,\r\n    PubkeyResolver,\r\n    TextResolver,\r\n    ExtendedResolver\r\n{\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    )\r\n        public\r\n        view\r\n        override(\r\n            ABIResolver,\r\n            AddrResolver,\r\n            ContentHashResolver,\r\n            DNSResolver,\r\n            InterfaceResolver,\r\n            NameResolver,\r\n            PubkeyResolver,\r\n            TextResolver,\r\n            ExtendedResolver\r\n        )\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceID);\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/text-resolver/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "contracts/diamond-resolver/facets/public-resolver/text-resolver/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../../base/DiamondResolverUtil.sol\";\nimport \"./ITextResolver.sol\";\n\nbytes32 constant TEXT_RESOLVER_STORAGE = keccak256(\"optidomains.resolver.TextResolverStorage\");\n\nlibrary TextResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"optidomains.contracts.storage.TextResolverStorage\");\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\nabstract contract TextResolver is ITextResolver, DiamondResolverUtil, IERC165 {\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external virtual authorised(node) {\n        _attest(node, keccak256(abi.encodePacked(TEXT_RESOLVER_STORAGE, key)), abi.encode(value));\n        emit TextChanged(node, key, key, value);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view virtual override returns (string memory) {\n        return abi.decode(_readAttestation(node, keccak256(abi.encodePacked(TEXT_RESOLVER_STORAGE, key))), (string));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(ITextResolver).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/test/TestAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../base/DiamondResolverUtil.sol\";\n\nlibrary AddrResolverStorage {\n    struct Layout {\n        mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('optidomains.contracts.storage.AddrResolverStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n\ncontract TestAddrResolver is\n    DiamondResolverUtil,\n    IERC165\n{\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(\n        bytes32 node,\n        address a\n    ) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(\n        bytes32 node\n    ) public view virtual returns (address payable) {\n        return payable(address(1));\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public virtual authorised(node) {\n        revert(\"Unsupported\");\n    }\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) public view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return false;\n    }\n\n    function bytesToAddress(\n        bytes memory b\n    ) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "contracts/diamond-resolver/facets/test/TestWeirdResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport \"../base/DiamondResolverUtil.sol\";\n\ncontract TestWeirdResolver is\n    DiamondResolverUtil,\n    IERC165\n{\n    // Only immutable works\n    uint256 immutable weirdConst;\n\n    constructor(uint256 _weirdConst) {\n        weirdConst = _weirdConst;\n    }\n\n    function weird(\n        bytes32 node\n    ) external virtual view returns(uint256) {\n        return weirdConst;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/diamond-resolver/IDiamondResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport \"@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol\";\r\nimport \"./IMulticallable.sol\";\r\nimport \"./INameWrapperRegistry.sol\";\r\n\r\ninterface IDiamondResolver is ISolidStateDiamond, IMulticallable {\r\n  function registry() external view returns(INameWrapperRegistry);\r\n}"
    },
    "contracts/diamond-resolver/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "contracts/diamond-resolver/INameWrapperRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport {ENS} from \"../registry/ENS.sol\";\r\nimport {INameWrapper} from \"../wrapper/INameWrapper.sol\";\r\n\r\ninterface INameWrapperRegistry {\r\n  function ens() external view returns(ENS);\r\n  function attestation() external view returns(address);\r\n  function forward(INameWrapper wrapper) external view returns(INameWrapper);\r\n  function backward(INameWrapper wrapper) external view returns(INameWrapper);\r\n  function isNameWrapper(address wrapper) external view returns(bool);\r\n  function ownerOf(bytes32 node) external view returns(address);\r\n\r\n  function upgrade(INameWrapper _old, INameWrapper _new) external;\r\n  function setAttestation(address _attestation) external;\r\n}\r\n\r\ninterface IHasNameWrapperRegistry {\r\n  function registry() external view returns(INameWrapperRegistry);\r\n}"
    },
    "contracts/diamond-resolver/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IMulticallable.sol\";\nimport \"@solidstate/contracts/interfaces/IERC165.sol\";\n\nabstract contract Multicallable is IMulticallable, IERC165 {\n    function _multicall(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) internal returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (nodehash != bytes32(0)) {\n                bytes32 txNamehash = bytes32(data[i][4:36]);\n                require(\n                    txNamehash == nodehash,\n                    \"multicall: All records must have a matching namehash\"\n                );\n            }\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    // This function provides an extra security check when called\n    // from priviledged contracts (such as EthRegistrarController)\n    // that can set records on behalf of the node owners\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        return _multicall(nodehash, data);\n    }\n\n    function multicall(\n        bytes[] calldata data\n    ) public override returns (bytes[] memory results) {\n        return _multicall(bytes32(0), data);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override(IERC165) returns (bool) {\n        return interfaceID == type(IMulticallable).interfaceId;\n    }\n}\n"
    },
    "contracts/diamond-resolver/NameWrapperRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.17 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@solidstate/contracts/interfaces/IERC165.sol\";\r\nimport \"./INameWrapperRegistry.sol\";\r\n\r\ncontract NameWrapperRegistry is INameWrapperRegistry, Ownable, IERC165 {\r\n    ENS public immutable ens;\r\n    address public attestation;\r\n    mapping(address => bool) public isNameWrapper;\r\n    mapping(INameWrapper => INameWrapper) public forward;\r\n    mapping(INameWrapper => INameWrapper) public backward;\r\n\r\n    constructor(ENS _ens) {\r\n        ens = _ens;\r\n    }\r\n\r\n    event NameWrapperUpgraded(\r\n        address indexed oldNameWrapper,\r\n        address indexed newNameWrapper\r\n    );\r\n\r\n    function upgrade(INameWrapper _old, INameWrapper _new) external onlyOwner {\r\n        require(\r\n            _new.supportsInterface(type(INameWrapper).interfaceId),\r\n            \"New Not NameWrapper\"\r\n        );\r\n\r\n        if (address(_old) == address(0)) {\r\n            isNameWrapper[address(_new)] = true;\r\n        } else {\r\n            require(isNameWrapper[address(_old)], \"Old Not NameWrapper\");\r\n\r\n            if (forward[_old] != INameWrapper(address(0))) {\r\n                delete forward[forward[_old]];\r\n                delete backward[forward[_old]];\r\n            }\r\n\r\n            forward[_old] = _new;\r\n            backward[_new] = _old;\r\n\r\n            isNameWrapper[address(_new)] = true;\r\n        }\r\n\r\n        emit NameWrapperUpgraded(address(_old), address(_new));\r\n    }\r\n\r\n    event SetAttestation(address indexed attestation);\r\n    function setAttestation(address _attestation) external onlyOwner {\r\n        attestation = _attestation;\r\n        emit SetAttestation(attestation);\r\n    }\r\n\r\n    function ownerOf(bytes32 node) public view returns(address owner) {\r\n        owner = ens.owner(node);\r\n        if (isNameWrapper[owner]) {\r\n            owner = INameWrapper(owner).ownerOf(uint256(node));\r\n        }\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override(IERC165) returns (bool) {\r\n        return interfaceID == type(INameWrapperRegistry).interfaceId;\r\n    }\r\n}\r\n"
    },
    "contracts/diamond-resolver/SolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport { IOwnable, Ownable, OwnableInternal } from '@solidstate/contracts/access/ownable/Ownable.sol';\r\nimport { ISafeOwnable, SafeOwnable } from '@solidstate/contracts/access/ownable/SafeOwnable.sol';\r\nimport { IERC173 } from '@solidstate/contracts/interfaces/IERC173.sol';\r\nimport { DiamondBase } from '@solidstate/contracts/proxy/diamond/base/DiamondBase.sol';\r\nimport { DiamondFallback, IDiamondFallback } from '@solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol';\r\nimport { DiamondReadable, IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol';\r\nimport { DiamondWritable, IDiamondWritable } from '@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol';\r\nimport { ISolidStateDiamond, IERC165 } from '@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol';\r\nimport { ERC165BaseInternal } from \"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\";\r\nimport \"./DiamondBaseExtendable.sol\";\r\n\r\n/**\r\n * @title SolidState \"Diamond\" proxy reference implementation\r\n * Overrided to fix non-virtual function in ERC165Base implementation\r\n */\r\nabstract contract SolidStateDiamond is\r\n    ISolidStateDiamond,\r\n    DiamondBaseExtendable,\r\n    DiamondReadable,\r\n    DiamondWritable,\r\n    SafeOwnable,\r\n    ERC165BaseInternal\r\n{\r\n    constructor(address _owner) {\r\n        initialize(_owner, address(0));\r\n    }\r\n\r\n    struct Initialization {\r\n        bool initialized;\r\n    }\r\n\r\n    function initialize(address _owner, address _fallback) public virtual {\r\n        Initialization storage initialization;\r\n        bytes32 slot = keccak256(\"optidomains.contracts.initialization\");\r\n        assembly {\r\n            initialization.slot := slot\r\n        }\r\n\r\n        require(!initialization.initialized, \"Initialized\");\r\n\r\n        if (_fallback == address(0)) {\r\n            bytes4[] memory selectors = new bytes4[](13);\r\n            uint256 selectorIndex;\r\n\r\n            // register DiamondFallback\r\n\r\n            selectors[selectorIndex++] = IDiamondFallback\r\n                .getFallbackAddress\r\n                .selector;\r\n            selectors[selectorIndex++] = IDiamondFallback\r\n                .setFallbackAddress\r\n                .selector;\r\n            selectors[selectorIndex++] = IDiamondBaseExtendable\r\n                .getImplementation\r\n                .selector;\r\n\r\n            // register DiamondWritable\r\n\r\n            selectors[selectorIndex++] = IDiamondWritable.diamondCut.selector;\r\n\r\n            // register DiamondReadable\r\n\r\n            selectors[selectorIndex++] = IDiamondReadable.facets.selector;\r\n            selectors[selectorIndex++] = IDiamondReadable\r\n                .facetFunctionSelectors\r\n                .selector;\r\n            selectors[selectorIndex++] = IDiamondReadable.facetAddresses.selector;\r\n            selectors[selectorIndex++] = IDiamondReadable.facetAddress.selector;\r\n\r\n            // register ERC165\r\n\r\n            selectors[selectorIndex++] = IERC165.supportsInterface.selector;\r\n\r\n            // register SafeOwnable\r\n\r\n            selectors[selectorIndex++] = Ownable.owner.selector;\r\n            selectors[selectorIndex++] = SafeOwnable.nomineeOwner.selector;\r\n            selectors[selectorIndex++] = Ownable.transferOwnership.selector;\r\n            selectors[selectorIndex++] = SafeOwnable.acceptOwnership.selector;\r\n\r\n            // diamond cut\r\n\r\n            FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n            facetCuts[0] = FacetCut({\r\n                target: address(this),\r\n                action: FacetCutAction.ADD,\r\n                selectors: selectors\r\n            });\r\n\r\n            _diamondCut(facetCuts, address(0), '');\r\n        } else {\r\n            _setFallbackAddress(_fallback);\r\n        }\r\n\r\n        _setSupportsInterface(type(IDiamondBaseExtendable).interfaceId, true);\r\n        _setSupportsInterface(type(IDiamondFallback).interfaceId, true);\r\n        _setSupportsInterface(type(IDiamondWritable).interfaceId, true);\r\n        _setSupportsInterface(type(IDiamondReadable).interfaceId, true);\r\n        _setSupportsInterface(type(IERC165).interfaceId, true);\r\n        _setSupportsInterface(type(IERC173).interfaceId, true);\r\n\r\n        // set owner\r\n\r\n        _setOwner(_owner);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _transferOwnership(\r\n        address account\r\n    ) internal virtual override(OwnableInternal, SafeOwnable) {\r\n        super._transferOwnership(account);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    ) public view virtual override(IERC165) returns (bool result) {\r\n        result = _supportsInterface(interfaceID);\r\n        if (!result) {\r\n            address fallbackAddress = _getFallbackAddress();\r\n            if (fallbackAddress != address(0)) {\r\n                result = result || IERC165(fallbackAddress).supportsInterface(interfaceID);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\n\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal.\n     * @param self The first bytes to compare.\n     * @param other The second bytes to compare.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first bytes to compare.\n     * @param offset The offset of self.\n     * @param len    The length of self.\n     * @param other The second bytes to compare.\n     * @param otheroffset The offset of the other string.\n     * @param otherlen    The length of the other string.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        if (offset + len > self.length) {\n            revert OffsetOutOfBoundsError(offset + len, self.length);\n        }\n        if (otheroffset + otherlen > other.length) {\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\n        }\n\n        uint256 shortest = len;\n        if (otherlen < len) shortest = otherlen;\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }\n                int256 diff = int256(a & mask) - int256(b & mask);\n                if (diff != 0) return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @param len The number of bytes to compare\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal with offsets.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset\n    ) internal pure returns (bool) {\n        return\n            keccak(self, offset, self.length - offset) ==\n            keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\n     *      they are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == offset + other.length &&\n            equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == other.length &&\n            equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n     * @dev Returns the 8-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 8 bits of the string, interpreted as an integer.\n     */\n    function readUint8(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n     * @dev Returns the 16-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 16 bits of the string, interpreted as an integer.\n     */\n    function readUint16(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bits of the string, interpreted as an integer.\n     */\n    function readUint32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes20(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(\n                mload(add(add(self, 32), idx)),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\n            )\n        }\n    }\n\n    /*\n     * @dev Returns the n byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes.\n     * @param len The number of bytes.\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytesN(\n        bytes memory self,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n     * @dev Copies a substring into a new byte string.\n     * @param self The byte string to copy from.\n     * @param offset The offset to start copying at.\n     * @param len The number of bytes to copy.\n     */\n    function substring(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(\n        bytes memory self,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /**\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\n     * @param self The string to search\n     * @param off The offset to start searching at\n     * @param len The number of bytes to search\n     * @param needle The byte to search for\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n     */\n    function find(\n        bytes memory self,\n        uint256 off,\n        uint256 len,\n        bytes1 needle\n    ) internal pure returns (uint256) {\n        for (uint256 idx = off; idx < off + len; idx++) {\n            if (self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n"
    },
    "contracts/dnssec-oracle/RRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\n */\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /**\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The length of the DNS name at 'offset', in bytes.\n     */\n    function nameLength(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /**\n     * @dev Returns a DNS format name at the specified offset of self.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return ret The name.\n     */\n    function readName(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes memory ret) {\n        uint256 len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /**\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The number of labels in the DNS name at 'offset', in bytes.\n     */\n    function labelCount(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint256 labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint256 constant RRSIG_TYPE = 0;\n    uint256 constant RRSIG_ALGORITHM = 2;\n    uint256 constant RRSIG_LABELS = 3;\n    uint256 constant RRSIG_TTL = 4;\n    uint256 constant RRSIG_EXPIRATION = 8;\n    uint256 constant RRSIG_INCEPTION = 12;\n    uint256 constant RRSIG_KEY_TAG = 16;\n    uint256 constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(\n        bytes memory data\n    ) internal pure returns (SignedSet memory self) {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(\n            RRSIG_SIGNER_NAME + self.signerName.length,\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\n        );\n    }\n\n    function rrs(\n        SignedSet memory rrset\n    ) internal pure returns (RRIterator memory) {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /**\n     * @dev An iterator over resource records.\n     */\n    struct RRIterator {\n        bytes data;\n        uint256 offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint256 rdataOffset;\n        uint256 nextOffset;\n    }\n\n    /**\n     * @dev Begins iterating over resource records.\n     * @param self The byte string to read from.\n     * @param offset The offset to start reading at.\n     * @return ret An iterator object.\n     */\n    function iterateRRs(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (RRIterator memory ret) {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /**\n     * @dev Returns true iff there are more RRs to iterate.\n     * @param iter The iterator to check.\n     * @return True iff the iterator has finished.\n     */\n    function done(RRIterator memory iter) internal pure returns (bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /**\n     * @dev Moves the iterator to the next resource record.\n     * @param iter The iterator to advance.\n     */\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint256 rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /**\n     * @dev Returns the name of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the owner name from the RR.\n     */\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.offset,\n                nameLength(iter.data, iter.offset)\n            );\n    }\n\n    /**\n     * @dev Returns the rdata portion of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the RR's RDATA.\n     */\n    function rdata(\n        RRIterator memory iter\n    ) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.rdataOffset,\n                iter.nextOffset - iter.rdataOffset\n            );\n    }\n\n    uint256 constant DNSKEY_FLAGS = 0;\n    uint256 constant DNSKEY_PROTOCOL = 2;\n    uint256 constant DNSKEY_ALGORITHM = 3;\n    uint256 constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(\n            offset + DNSKEY_PUBKEY,\n            length - DNSKEY_PUBKEY\n        );\n    }\n\n    uint256 constant DS_KEY_TAG = 0;\n    uint256 constant DS_ALGORITHM = 2;\n    uint256 constant DS_DIGEST_TYPE = 3;\n    uint256 constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    function isSubdomainOf(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        uint256 off = 0;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        while (counts > othercounts) {\n            off = progress(self, off);\n            counts--;\n        }\n\n        return self.equals(off, other, 0);\n    }\n\n    function compareNames(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint256 off;\n        uint256 otheroff;\n        uint256 prevoff;\n        uint256 otherprevoff;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if (otheroff == 0) {\n            return 1;\n        }\n\n        return\n            self.compare(\n                prevoff + 1,\n                self.readUint8(prevoff),\n                other,\n                otherprevoff + 1,\n                other.readUint8(otherprevoff)\n            );\n    }\n\n    /**\n     * @dev Compares two serial numbers using RFC1982 serial number math.\n     */\n    function serialNumberGte(\n        uint32 i1,\n        uint32 i2\n    ) internal pure returns (bool) {\n        unchecked {\n            return int32(i1) - int32(i2) >= 0;\n        }\n    }\n\n    function progress(\n        bytes memory body,\n        uint256 off\n    ) internal pure returns (uint256) {\n        return off + 1 + body.readUint8(off);\n    }\n\n    /**\n     * @dev Computes the keytag for a chunk of data.\n     * @param data The data to compute a keytag for.\n     * @return The computed key tag.\n     */\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\n        /* This function probably deserves some explanation.\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n         *\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n         *         uint ac;\n         *         for (uint i = 0; i < data.length; i++) {\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n         *         }\n         *         return uint16(ac + (ac >> 16));\n         *     }\n         *\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\n         * large words work in our favour.\n         *\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\n         * effectively summing 16 different numbers with each EVM ADD opcode.\n         *\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\n         * and the remaining sums can be done just on ac1.\n         */\n        unchecked {\n            require(data.length <= 8192, \"Long keys not permitted\");\n            uint256 ac1;\n            uint256 ac2;\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(add(add(data, 32), i))\n                }\n                if (i + 32 > data.length) {\n                    uint256 unused = 256 - (data.length - i) * 8;\n                    word = (word >> unused) << unused;\n                }\n                ac1 +=\n                    (word &\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n                    8;\n                ac2 += (word &\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n            }\n            ac1 =\n                (ac1 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac1 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac2 =\n                (ac2 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac2 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac1 = (ac1 << 8) + ac2;\n            ac1 =\n                (ac1 &\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\n                    32);\n            ac1 =\n                (ac1 &\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\n                    64);\n            ac1 =\n                (ac1 &\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\n                (ac1 >> 128);\n            ac1 += (ac1 >> 16) & 0xFFFF;\n            return uint16(ac1);\n        }\n    }\n}\n"
    },
    "contracts/ethregistrar/IBaseRegistrar.sol": {
      "content": "import \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/reverseRegistrar/IReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IReverseRegistrar {\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
    },
    "contracts/reverseRegistrar/ReverseClaimer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IReverseRegistrar} from \"../reverseRegistrar/IReverseRegistrar.sol\";\n\ncontract ReverseClaimer {\n    bytes32 constant ADDR_REVERSE_NODE =\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    constructor(ENS ens, address claimant) {\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n        reverseRegistrar.claim(claimant);\n    }\n}\n"
    },
    "contracts/wrapper/IMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface IMetadataService {\n    function uri(uint256) external view returns (string memory);\n}\n"
    },
    "contracts/wrapper/INameWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\nimport \"./INameWrapperUpgrade.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant CANNOT_APPROVE = 64;\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\nuint32 constant IS_DOT_ETH = 1 << 17;\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\nuint32 constant CAN_DO_EVERYTHING = 0;\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\n// all fuses apart from IS_DOT_ETH\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}\n"
    },
    "contracts/wrapper/INameWrapperUpgrade.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface INameWrapperUpgrade {\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2499
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}